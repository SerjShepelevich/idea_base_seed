diff --git a/README.md b/README.md
new file mode 100644
index 0000000..45a308b
--- /dev/null
+++ b/README.md
@@ -0,0 +1,18 @@
+# idea_base_seed — база идей и навыков
+
+Этот репозиторий — единое место, где мы храним:
+- **Идеи / решения** (docs/)
+- **Навыки (skills)** — переносимые “skill-packs”, которые можно подключать к любому проекту через `skills.lock.yaml`
+
+## Куда смотреть
+- `docs/IDEAS.md` — список идей (ссылки на карточки)
+- `docs/DECISIONS.md` — журнал решений
+- `docs/SKILLS.md` — **операционный гайд** по навыкам (как подключать/обновлять/добавлять)
+- `skills/packs/` — сами skill-packs
+- `skills/skillctl.py` — минимальный менеджер (git → copy, без авто‑выполнения кода)
+
+## Быстрый старт (подключить skill в проект)
+1) В проекте создайте `skills.lock.yaml` (см. `docs/SKILLS.md`)
+2) Установите зависимость: `pip install pyyaml`
+3) Примените lock:  
+   `python3 /ABS/PATH/TO/idea_base_seed/skills/skillctl.py apply --project . --lock skills.lock.yaml`
diff --git a/docs/SKILLS.md b/docs/SKILLS.md
index a78819b..49f0fe7 100644
--- a/docs/SKILLS.md
+++ b/docs/SKILLS.md
@@ -1,28 +1,137 @@
-# Skills: как подключать навыки в проекты
+# Skills — как пользоваться библиотекой навыков
 
-В `idea_base_seed` навыки живут в `skills/packs/`.
+Эта инструкция живёт **в репозитории**, чтобы не “растворяться туманом”.
+Если нужно подключить навык или добавить новый — открываете этот файл и делаете по шагам.
 
-Проект подключает навык через `skills.lock.yaml`:
+---
 
-- `repo`: URL репозитория с навыками (обычно `idea_base_seed`)
-- `ref`: tag/commit/branch (рекомендуется tag или commit)
-- `path`: путь до пакета внутри репозитория (например `skills/packs/project_analyzer`)
-- `install.target`: куда копировать в проект (`tools/skills/<id>`)
+## 1) Модель: suggest → pin → use
+
+- **suggest** — нашли/придумали навык
+- **pin** — зафиксировали версию в проекте (`skills.lock.yaml`)
+- **use** — применили (установили) и запустили **явно**, без магии
+
+Почему так:
+- поиск навыков разрешён и полезен
+- но воспроизводимость важнее: проект должен “помнить” точную версию
+
+---
+
+## 2) Где лежат навыки в этом репозитории
+
+- Реестр: `skills/packs/<skill_id>/`
+- Шаблон lock: `skills/templates/skills.lock.yaml`
+- Менеджер: `skills/skillctl.py` (git → copy, без авто‑запуска)
+
+---
+
+## 3) Подключить навык в любой проект
+
+### 3.1 Создать `skills.lock.yaml` в проекте
+
+Рекомендуется **tag или commit**, не `main`.
 
-## Минимальная схема lock (пример)
 ```yaml
 skills:
   - id: project_analyzer
     source:
       repo: https://github.com/SerjShepelevich/idea_base_seed.git
-      ref: main
+      ref: skills-v0.1.0      # tag или commit
       path: skills/packs/project_analyzer
     install:
       mode: copy
       target: tools/skills/project_analyzer
 ```
 
-## Применение
-1) `pip install pyyaml`
-2) `python3 skillctl.py apply --project . --lock skills.lock.yaml`
-3) Запуск entrypoint навыка — вручную (см. README каждого skillpack).
+### 3.2 Применить lock (установить skillpack)
+
+Требования:
+- `git` установлен
+- `pip install pyyaml`
+
+Команда (из корня проекта):
+```bash
+pip install pyyaml
+python3 /ABS/PATH/TO/idea_base_seed/skills/skillctl.py apply --project . --lock skills.lock.yaml
+```
+
+Что будет:
+- файлы навыка появятся в `tools/skills/<id>/`
+- создастся кэш `.skills_cache/` в проекте (его обычно добавляют в `.gitignore`)
+
+---
+
+## 4) Запуск первого навыка: `project_analyzer` (MVP)
+
+Запуск из корня проекта:
+```bash
+python3 tools/skills/project_analyzer/src/project_analyzer.py --root . --out plan/project_architecture.json
+```
+
+Контракт:
+- выходной файл: `plan/project_architecture.json`
+
+Smoke-test:
+```bash
+python3 -m unittest tools/skills/project_analyzer/tests/test_project_analyzer.py
+```
+
+---
+
+## 5) Обновить навык в проекте
+
+1) В проекте меняете `ref:` в `skills.lock.yaml` на новый tag/commit  
+2) Повторяете apply:
+```bash
+python3 /ABS/PATH/TO/idea_base_seed/skills/skillctl.py apply --project . --lock skills.lock.yaml
+```
+
+---
+
+## 6) Добавить новый навык (skill-pack) в `idea_base_seed`
+
+### 6.1 Шаблон структуры
+```
+skills/packs/<skill_id>/
+  skill.yaml
+  README.md
+  src/
+  tests/
+```
+
+### 6.2 Минимальный чек-лист качества
+
+Навык считается не-черновиком, если:
+- есть `skill.yaml` с `id/version/status/entrypoints/contracts`
+- есть `README.md` (как запускать)
+- есть `tests/` (хотя бы smoke)
+- есть tag `skills-vX.Y.Z` после изменения (чтобы проекты могли pin)
+
+---
+
+## 7) Типовые проблемы
+
+**A) PyYAML не найден**
+```bash
+pip install pyyaml
+```
+
+**B) `pack not found`**
+Проверьте `repo/ref/path` в lock. Самая частая ошибка — неверный `path`.
+
+**C) “не обновилось”**
+Если `ref` указывает на `main`, вы ловите дрейф. Используйте tag/commit.
+
+---
+
+## 8) Рекомендованная политика версий
+
+После мержа набора навыков:
+```bash
+git tag skills-v0.1.0
+git push --tags
+```
+
+И в проектах:
+- `ref: skills-v0.1.0`
+- дальше обновлять осознанно (меняя `ref`)
diff --git a/idea_base.patch b/idea_base.patch
deleted file mode 100644
index 0d75f7e..0000000
--- a/idea_base.patch
+++ /dev/null
@@ -1,632 +0,0 @@
-diff --git a/README.md b/README.md
-new file mode 100644
-index 0000000..1111111
---- /dev/null
-+++ b/README.md
-@@ -0,0 +1,24 @@
-+# idea_base_seed — база идей и навыков (skill-library)
-+
-+Цель репозитория — хранить **переносимую экспертизу** в виде версионируемых артефактов:
-+- идеи / решения (docs/)
-+- навыки (skills/) — “skill-packs”, которые можно подключать в другие проекты через `skills.lock.yaml`.
-+
-+## Быстрый старт (skills)
-+- Инструкция: `docs/SKILLS.md`
-+- Реестр навыков: `skills/packs/`
-+- Первый навык (MVP): `skills/packs/project_analyzer/`
-+
-+> Дисциплина: suggest → pin → use
-+> Идея: можно искать подходящий навык, но использование фиксируется в `skills.lock.yaml`.
-+
-+## Что внутри
-+- `docs/IDEAS.md` — список идей + ссылки на карточки
-+- `docs/DECISIONS.md` — журнал решений (governance)
-+- `docs/SKILLS.md` — операционный гайд по навыкам
-+- `skills/` — библиотека навыков и минимальный менеджер `skillctl.py`
-diff --git a/docs/SKILLS.md b/docs/SKILLS.md
-new file mode 100644
-index 0000000..2222222
---- /dev/null
-+++ b/docs/SKILLS.md
-@@ -0,0 +1,133 @@
-+# Skills — как пользоваться библиотекой навыков
-+
-+Эта инструкция живёт здесь специально, чтобы “не растворяться туманом”.
-+Если нужно подключить навык или добавить новый — открываете этот файл и делаете по шагам.
-+
-+---
-+
-+## 1) Модель подключения навыка
-+**suggest → pin → use**
-+
-+- **suggest** — нашли/придумали навык
-+- **pin** — зафиксировали версию в проекте (`skills.lock.yaml`)
-+- **use** — применили (установили) и запустили **явно**, без магии
-+
-+Почему так:
-+- поиск навыков разрешён и полезен
-+- но воспроизводимость важнее: проект должен “помнить” точную версию
-+
-+---
-+
-+## 2) Где лежат навыки в этом репозитории
-+- Реестр: `skills/packs/<skill_id>/`
-+- Шаблон lock: `skills/templates/skills.lock.yaml`
-+- Инсталлятор: `skills/skillctl.py` (git → copy, без авто-запуска)
-+
-+---
-+
-+## 3) Подключить навык в любой проект
-+
-+### 3.1 Создать `skills.lock.yaml` в проекте
-+Пример (рекомендуется **tag или commit**, не `main`):
-+
-+```yaml
-+skills:
-+  - id: project_analyzer
-+    source:
-+      repo: https://github.com/SerjShepelevich/idea_base_seed.git
-+      ref: skills-v0.1.0      # tag или commit
-+      path: skills/packs/project_analyzer
-+    install:
-+      mode: copy
-+      target: tools/skills/project_analyzer
-+```
-+
-+### 3.2 Применить lock (установить skillpack)
-+Требования:
-+- `git` установлен
-+- `pip install pyyaml`
-+
-+Команда:
-+```bash
-+pip install pyyaml
-+python3 /ABS/PATH/TO/idea_base_seed/skills/skillctl.py apply --project . --lock skills.lock.yaml
-+```
-+
-+Что будет:
-+- файлы навыка появятся в `tools/skills/project_analyzer/`
-+- создастся кэш `.skills_cache/` в проекте (его обычно игнорируют в git)
-+
-+---
-+
-+## 4) Запуск первого навыка: `project_analyzer` (MVP)
-+
-+Запуск из корня проекта:
-+```bash
-+python3 tools/skills/project_analyzer/src/project_analyzer.py --root . --out plan/project_architecture.json
-+```
-+
-+Контракт:
-+- выходной файл: `plan/project_architecture.json`
-+
-+Smoke-test:
-+```bash
-+python3 -m unittest tools/skills/project_analyzer/tests/test_project_analyzer.py
-+```
-+
-+---
-+
-+## 5) Обновить навык в проекте
-+1) В проекте меняете `ref:` в `skills.lock.yaml` на новый tag/commit
-+2) Повторяете apply:
-+```bash
-+python3 /ABS/PATH/TO/idea_base_seed/skills/skillctl.py apply --project . --lock skills.lock.yaml
-+```
-+
-+---
-+
-+## 6) Добавить новый навык (skill-pack) в `idea_base_seed`
-+
-+### 6.1 Шаблон структуры
-+```
-+skills/packs/<skill_id>/
-+  skill.yaml
-+  README.md
-+  src/
-+  tests/
-+```
-+
-+### 6.2 Минимальный чек-лист качества
-+Навык считается не-черновиком, если:
-+- есть `skill.yaml` с `id/version/status/entrypoints/contracts`
-+- есть `README.md` (как запускать)
-+- есть `tests/` (хотя бы smoke)
-+- есть tag `skills-vX.Y.Z` после изменения (чтобы проекты могли pin)
-+
-+---
-+
-+## 7) Типовые проблемы
-+**A) PyYAML не найден**
-+```bash
-+pip install pyyaml
-+```
-+
-+**B) `pack not found`**
-+Проверьте `repo/ref/path` в lock. Самая частая ошибка — неверный `path`.
-+
-+**C) “не обновилось”**
-+Если `ref` указывает на `main`, вы ловите дрейф. Используйте tag/commit.
-+
-+---
-+
-+## 8) Рекомендованная политика версий
-+После мержа набора навыков:
-+```bash
-+git tag skills-v0.1.0
-+git push --tags
-+```
-+
-+И в проектах:
-+- `ref: skills-v0.1.0`
-+- дальше обновлять осознанно (меняя `ref`)
-diff --git a/skills/README.md b/skills/README.md
-new file mode 100644
-index 0000000..3333333
---- /dev/null
-+++ b/skills/README.md
-@@ -0,0 +1,9 @@
-+# skills/ — библиотека навыков (skill-packs)
-+
-+Тут лежит переносимая экспертиза в виде папок + кода.
-+
-+- `packs/` — сами навыки
-+- `templates/skills.lock.yaml` — шаблон pin-файла
-+- `skillctl.py` — минимальный менеджер (git → copy)
-+
-+Главная инструкция: `docs/SKILLS.md`
-diff --git a/skills/templates/skills.lock.yaml b/skills/templates/skills.lock.yaml
-new file mode 100644
-index 0000000..4444444
---- /dev/null
-+++ b/skills/templates/skills.lock.yaml
-@@ -0,0 +1,11 @@
-+# skills.lock.yaml (template for projects)
-+skills:
-+  - id: project_analyzer
-+    source:
-+      repo: https://github.com/SerjShepelevich/idea_base_seed.git
-+      ref: skills-v0.1.0   # лучше tag или commit
-+      path: skills/packs/project_analyzer
-+    install:
-+      mode: copy
-+      target: tools/skills/project_analyzer
-diff --git a/skills/skillctl.py b/skills/skillctl.py
-new file mode 100755
-index 0000000..5555555
---- /dev/null
-+++ b/skills/skillctl.py
-@@ -0,0 +1,165 @@
-+#!/usr/bin/env python3
-+"""skillctl.py — минимальный менеджер skill-packs (git → copy).
-+
-+Задача: детерминированно “притащить” skillpack в проект по `skills.lock.yaml`.
-+
-+Важно:
-+- не выполняет код навыка автоматически (никакой магии)
-+- только копирует файлы
-+"""
-+from __future__ import annotations
-+
-+import argparse
-+import shutil
-+import subprocess
-+from dataclasses import dataclass
-+from hashlib import sha256
-+from pathlib import Path
-+from typing import List, Optional
-+
-+try:
-+    import yaml  # type: ignore
-+except Exception as e:  # pragma: no cover
-+    raise SystemExit(
-+        "PyYAML не найден. Установите: pip install pyyaml\n"
-+        f"Оригинальная ошибка импорта: {e}"
-+    )
-+
-+
-+@dataclass(frozen=True)
-+class SkillSource:
-+    repo: str
-+    ref: str
-+    path: str
-+
-+
-+@dataclass(frozen=True)
-+class SkillInstall:
-+    mode: str
-+    target: str
-+
-+
-+@dataclass(frozen=True)
-+class SkillSpec:
-+    id: str
-+    source: SkillSource
-+    install: SkillInstall
-+
-+
-+def _run(cmd: List[str], cwd: Optional[Path] = None) -> None:
-+    p = subprocess.run(cmd, cwd=str(cwd) if cwd else None, check=False, text=True)
-+    if p.returncode != 0:
-+        raise SystemExit(f"[ERR] command failed ({p.returncode}): {' '.join(cmd)}")
-+
-+
-+def _repo_cache_dir(cache_root: Path, repo: str, ref: str) -> Path:
-+    key = sha256(f"{repo}::{ref}".encode("utf-8")).hexdigest()[:16]
-+    return cache_root / key
-+
-+
-+def _ensure_repo_checked_out(cache_dir: Path, repo: str, ref: str) -> Path:
-+    if not cache_dir.exists():
-+        cache_dir.mkdir(parents=True, exist_ok=True)
-+        _run(["git", "clone", "--no-tags", "--depth", "1", repo, "."], cwd=cache_dir)
-+    _run(["git", "fetch", "--depth", "1", "origin", ref], cwd=cache_dir)
-+    _run(["git", "checkout", "--force", "FETCH_HEAD"], cwd=cache_dir)
-+    return cache_dir
-+
-+
-+def _load_lock(lock_path: Path) -> List[SkillSpec]:
-+    data = yaml.safe_load(lock_path.read_text(encoding="utf-8"))
-+    if not isinstance(data, dict) or "skills" not in data:
-+        raise SystemExit("[ERR] skills.lock.yaml должен содержать верхний ключ `skills`")
-+
-+    skills_raw = data["skills"]
-+    if not isinstance(skills_raw, list):
-+        raise SystemExit("[ERR] `skills` должен быть списком")
-+
-+    specs: List[SkillSpec] = []
-+    for item in skills_raw:
-+        if not isinstance(item, dict):
-+            raise SystemExit("[ERR] элемент `skills` должен быть объектом")
-+
-+        sid = str(item.get("id", "")).strip()
-+        if not sid:
-+            raise SystemExit("[ERR] у skill отсутствует `id`")
-+
-+        src = item.get("source", {})
-+        inst = item.get("install", {})
-+        try:
-+            source = SkillSource(
-+                repo=str(src["repo"]),
-+                ref=str(src.get("ref", "main")),
-+                path=str(src["path"]),
-+            )
-+            install = SkillInstall(
-+                mode=str(inst.get("mode", "copy")),
-+                target=str(inst.get("target", f"tools/skills/{sid}")),
-+            )
-+        except KeyError as e:
-+            raise SystemExit(f"[ERR] отсутствует обязательное поле в lock: {e}")
-+
-+        specs.append(SkillSpec(id=sid, source=source, install=install))
-+    return specs
-+
-+
-+def _install_copy(project: Path, src_dir: Path, target_rel: str) -> None:
-+    target = (project / target_rel).resolve()
-+    if target.exists():
-+        shutil.rmtree(target)
-+    target.parent.mkdir(parents=True, exist_ok=True)
-+    shutil.copytree(src_dir, target)
-+    print(f"[OK] installed -> {target_rel}")
-+
-+
-+def apply(project: Path, lock_path: Path) -> None:
-+    project = project.resolve()
-+    lock = (project / lock_path).resolve() if not lock_path.is_absolute() else lock_path.resolve()
-+    if not lock.exists():
-+        raise SystemExit(f"[ERR] lock not found: {lock}")
-+
-+    cache_root = project / ".skills_cache"
-+    cache_root.mkdir(parents=True, exist_ok=True)
-+
-+    specs = _load_lock(lock)
-+    print(f"[INFO] skills: {len(specs)}")
-+
-+    for spec in specs:
-+        cache_dir = _repo_cache_dir(cache_root, spec.source.repo, spec.source.ref)
-+        _ensure_repo_checked_out(cache_dir, spec.source.repo, spec.source.ref)
-+
-+        pack_dir = (cache_dir / spec.source.path).resolve()
-+        if not pack_dir.exists():
-+            raise SystemExit(f"[ERR] pack not found: {pack_dir}")
-+
-+        if spec.install.mode != "copy":
-+            raise SystemExit(f"[ERR] unsupported install mode: {spec.install.mode}")
-+
-+        _install_copy(project, pack_dir, spec.install.target)
-+
-+    print("[DONE] apply finished")
-+
-+
-+def main() -> None:
-+    ap = argparse.ArgumentParser()
-+    sub = ap.add_subparsers(dest="cmd", required=True)
-+
-+    ap_apply = sub.add_parser("apply", help="Install skills into a project")
-+    ap_apply.add_argument("--project", type=str, default=".", help="Path to target project")
-+    ap_apply.add_argument("--lock", type=str, default="skills.lock.yaml", help="Path to lock file (relative to project)")
-+
-+    args = ap.parse_args()
-+    if args.cmd == "apply":
-+        apply(Path(args.project), Path(args.lock))
-+
-+
-+if __name__ == "__main__":
-+    main()
-diff --git a/skills/packs/project_analyzer/skill.yaml b/skills/packs/project_analyzer/skill.yaml
-new file mode 100644
-index 0000000..6666666
---- /dev/null
-+++ b/skills/packs/project_analyzer/skill.yaml
-@@ -0,0 +1,18 @@
-+id: project_analyzer
-+version: 0.1.0
-+status: mvp
-+description: >
-+  MVP анализатора проекта: сканирует дерево файлов и Python-символы (AST),
-+  генерирует JSON архитектуры для навигации и автоматизации.
-+entrypoints:
-+  - name: scan
-+    command: python3 src/project_analyzer.py --root . --out plan/project_architecture.json
-+contracts:
-+  output_json: plan/project_architecture.json
-+permissions:
-+  default: read-only
-+  network: false
-+  system: false
-diff --git a/skills/packs/project_analyzer/README.md b/skills/packs/project_analyzer/README.md
-new file mode 100644
-index 0000000..7777777
---- /dev/null
-+++ b/skills/packs/project_analyzer/README.md
-@@ -0,0 +1,24 @@
-+# project_analyzer (MVP)
-+
-+## Назначение
-+Быстро собрать “карту проекта” (файлы + Python символы + импорты) в один JSON,
-+чтобы дальше:
-+- искать точки входа
-+- строить планы рефакторинга
-+- автоматизировать проверку регрессий
-+
-+## Запуск
-+Из корня проекта (после установки skillpack):
-+```bash
-+python3 tools/skills/project_analyzer/src/project_analyzer.py --root . --out plan/project_architecture.json
-+```
-+
-+## Выходной контракт
-+- `plan/project_architecture.json`
-+- сортировка детерминированная (пути/имена)
-+
-+## Что улучшать дальше
-+- граф импортов/зависимостей
-+- извлечение сигнатур функций и docstrings
-+- адаптеры под типовые “среды” (ROS2/Unitree/Flask)
-diff --git a/skills/packs/project_analyzer/src/__init__.py b/skills/packs/project_analyzer/src/__init__.py
-new file mode 100644
-index 0000000..8888888
---- /dev/null
-+++ b/skills/packs/project_analyzer/src/__init__.py
-@@ -0,0 +1 @@
-+# package marker
-diff --git a/skills/packs/project_analyzer/src/project_analyzer.py b/skills/packs/project_analyzer/src/project_analyzer.py
-new file mode 100755
-index 0000000..9999999
---- /dev/null
-+++ b/skills/packs/project_analyzer/src/project_analyzer.py
-@@ -0,0 +1,205 @@
-+#!/usr/bin/env python3
-+"""project_analyzer.py — MVP сканера проекта (Python AST + индекс файлов)."""
-+from __future__ import annotations
-+
-+import argparse
-+import ast
-+import json
-+import os
-+from dataclasses import dataclass
-+from datetime import datetime, timezone
-+from pathlib import Path
-+from typing import Any, Dict, Iterable, List, Optional, Tuple
-+
-+
-+DEFAULT_EXCLUDES = {
-+    ".git",
-+    ".venv",
-+    "venv",
-+    "__pycache__",
-+    ".mypy_cache",
-+    ".pytest_cache",
-+    "node_modules",
-+    "dist",
-+    "build",
-+    ".skills_cache",
-+    ".idea",
-+}
-+
-+
-+@dataclass(frozen=True)
-+class Symbol:
-+    kind: str
-+    name: str
-+    file: str
-+    lineno: int
-+    end_lineno: int
-+
-+
-+@dataclass(frozen=True)
-+class ImportRec:
-+    module: str
-+    name: Optional[str]
-+    file: str
-+    lineno: int
-+
-+
-+def iter_files(root: Path, excludes: Iterable[str]) -> Iterable[Path]:
-+    ex = set(excludes)
-+    for dirpath, dirnames, filenames in os.walk(root):
-+        dirnames[:] = [d for d in dirnames if d not in ex]
-+        for fn in filenames:
-+            yield Path(dirpath) / fn
-+
-+
-+def parse_python(path: Path) -> Tuple[List[Symbol], List[ImportRec]]:
-+    try:
-+        src = path.read_text(encoding="utf-8")
-+    except UnicodeDecodeError:
-+        src = path.read_text(encoding="latin-1")
-+
-+    try:
-+        tree = ast.parse(src, filename=str(path))
-+    except SyntaxError:
-+        return [], []
-+
-+    symbols: List[Symbol] = []
-+    imports: List[ImportRec] = []
-+
-+    for node in ast.walk(tree):
-+        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
-+            symbols.append(
-+                Symbol(
-+                    kind="function",
-+                    name=node.name,
-+                    file=str(path),
-+                    lineno=int(getattr(node, "lineno", 0) or 0),
-+                    end_lineno=int(getattr(node, "end_lineno", 0) or (getattr(node, "lineno", 0) or 0)),
-+                )
-+            )
-+        elif isinstance(node, ast.ClassDef):
-+            symbols.append(
-+                Symbol(
-+                    kind="class",
-+                    name=node.name,
-+                    file=str(path),
-+                    lineno=int(getattr(node, "lineno", 0) or 0),
-+                    end_lineno=int(getattr(node, "end_lineno", 0) or (getattr(node, "lineno", 0) or 0)),
-+                )
-+            )
-+        elif isinstance(node, ast.Import):
-+            for alias in node.names:
-+                imports.append(
-+                    ImportRec(
-+                        module=alias.name,
-+                        name=None,
-+                        file=str(path),
-+                        lineno=int(getattr(node, "lineno", 0) or 0),
-+                    )
-+                )
-+        elif isinstance(node, ast.ImportFrom):
-+            mod = node.module or ""
-+            for alias in node.names:
-+                imports.append(
-+                    ImportRec(
-+                        module=mod,
-+                        name=alias.name,
-+                        file=str(path),
-+                        lineno=int(getattr(node, "lineno", 0) or 0),
-+                    )
-+                )
-+
-+    symbols.sort(key=lambda s: (s.file, s.kind, s.name, s.lineno))
-+    imports.sort(key=lambda i: (i.file, i.module, i.name or "", i.lineno))
-+    return symbols, imports
-+
-+
-+def build_index(root: Path, excludes: Iterable[str]) -> Dict[str, Any]:
-+    root = root.resolve()
-+    files: List[Dict[str, Any]] = []
-+    symbols: List[Symbol] = []
-+    imports: List[ImportRec] = []
-+
-+    for p in iter_files(root, excludes):
-+        if p.is_dir():
-+            continue
-+        rel = str(p.resolve().relative_to(root))
-+        files.append({"path": rel, "suffix": p.suffix.lower(), "size": p.stat().st_size})
-+
-+        if p.suffix.lower() == ".py":
-+            s, im = parse_python(p)
-+            for x in s:
-+                symbols.append(Symbol(x.kind, x.name, rel, x.lineno, x.end_lineno))
-+            for x in im:
-+                imports.append(ImportRec(x.module, x.name, rel, x.lineno))
-+
-+    files.sort(key=lambda r: r["path"])
-+    symbols_sorted = sorted(symbols, key=lambda s: (s.file, s.kind, s.name, s.lineno))
-+    imports_sorted = sorted(imports, key=lambda i: (i.file, i.module, i.name or "", i.lineno))
-+
-+    return {
-+        "meta": {
-+            "generated_at": datetime.now(timezone.utc).isoformat(),
-+            "root": str(root),
-+            "excludes": sorted(set(excludes)),
-+            "version": "0.1.0",
-+        },
-+        "files": files,
-+        "symbols": [
-+            {"kind": s.kind, "name": s.name, "file": s.file, "lineno": s.lineno, "end_lineno": s.end_lineno}
-+            for s in symbols_sorted
-+        ],
-+        "imports": [
-+            {"module": i.module, "name": i.name, "file": i.file, "lineno": i.lineno}
-+            for i in imports_sorted
-+        ],
-+        "stats": {
-+            "files_total": len(files),
-+            "py_files": sum(1 for f in files if f["suffix"] == ".py"),
-+            "symbols_total": len(symbols_sorted),
-+            "imports_total": len(imports_sorted),
-+        },
-+    }
-+
-+
-+def main() -> None:
-+    ap = argparse.ArgumentParser()
-+    ap.add_argument("--root", type=str, default=".", help="Project root to scan")
-+    ap.add_argument("--out", type=str, default="plan/project_architecture.json", help="Output JSON path")
-+    ap.add_argument("--exclude", action="append", default=[], help="Extra exclude dir name (repeatable)")
-+    args = ap.parse_args()
-+
-+    root = Path(args.root).resolve()
-+    out_path = Path(args.out)
-+    excludes = sorted(DEFAULT_EXCLUDES.union(set(args.exclude)))
-+
-+    data = build_index(root, excludes)
-+    out_full = (root / out_path) if not out_path.is_absolute() else out_path
-+    out_full.parent.mkdir(parents=True, exist_ok=True)
-+    out_full.write_text(json.dumps(data, ensure_ascii=False, indent=2) + "\n", encoding="utf-8")
-+    print(f"[OK] wrote {out_full}")
-+
-+
-+if __name__ == "__main__":
-+    main()
-diff --git a/skills/packs/project_analyzer/tests/test_project_analyzer.py b/skills/packs/project_analyzer/tests/test_project_analyzer.py
-new file mode 100644
-index 0000000..aaaaaaa
---- /dev/null
-+++ b/skills/packs/project_analyzer/tests/test_project_analyzer.py
-@@ -0,0 +1,25 @@
-+from __future__ import annotations
-+
-+import tempfile
-+import unittest
-+from pathlib import Path
-+
-+from src.project_analyzer import build_index
-+
-+
-+class TestProjectAnalyzer(unittest.TestCase):
-+    def test_minimal(self) -> None:
-+        with tempfile.TemporaryDirectory() as td:
-+            root = Path(td)
-+            (root / "a.py").write_text("import os\n\nclass A: pass\n\ndef f():\n    return 1\n", encoding="utf-8")
-+            data = build_index(root, excludes=set())
-+            self.assertIn("meta", data)
-+            self.assertGreaterEqual(data["stats"]["files_total"], 1)
-+            self.assertGreaterEqual(data["stats"]["symbols_total"], 2)
-+            self.assertGreaterEqual(data["stats"]["imports_total"], 1)
-+
-+
-+if __name__ == "__main__":
-+    unittest.main()
diff --git a/skills/packs/project_analyzer/src/project_analyzer.py b/skills/packs/project_analyzer/src/project_analyzer.py
old mode 100644
new mode 100755
diff --git a/skills/skillctl.py b/skills/skillctl.py
old mode 100644
new mode 100755
